package hiveos;
##
## $Id$
##
## @PACKAGE@ @VERSION@
@copyright@
#
# RANCID - Really Awesome New Cisco confIg Differ
#
# hiveos.pm - aerohive hiveos rancid procedures
#
# based on iossb.pm.in revision 3472 &
# nxos.pm.in version 3843
#
# tested on configs pushed by hivemanager-ng 12.8.1.2:
#   model ap121, hiveos version 6.5r4
#   model ap121, hiveos version 6.5r8a
#   model ap121, hiveos version 6.5r8b
#   model ap121, hiveos version 6.5r9
#   model ap230, hiveos version 6.5r8b
#   model ap250, hiveos version 8.0r1a
#   model ap250, hiveos version 8.3r2
#   model ap250, hiveos version 8.3r5

# NOCOMMSTR:
#   always show by default on hiveos!
#   done for v2 reader 
#   not done for traps & other versions & hostnames

# passwd todo:
#   security-object AquafinGeneral security aaa radius-server primary 10.1.10.110 shared-secret ***
#   security-object AquafinGeneral security aaa radius-server accounting primary 10.1.10.110 shared-secret ***
#   security-object AquafinGeneral security aaa radius-server backup1 10.1.10.111 shared-secret ***
#   security-object AquafinGeneral security aaa radius-server accounting backup1 10.1.10.111 shared-secret ***


use 5.010;
use strict 'vars';
use warnings;
no warnings 'uninitialized';
require(Exporter);
our @ISA = qw(Exporter);

use rancid @VERSION@;

@ISA = qw(Exporter rancid main);
#XXX @Exporter::EXPORT = qw($VERSION @commandtable %commands @commands);

# load-time initialization
sub import {
    0;
}

# post-open(collection file) initialization
sub init {

    # add content lines and separators
    ProcessHistory("","","","!RANCID-CONTENT-TYPE: $devtype\n!\n");

    0;
}

# main loop of input of device output
sub inloop {
    my($INPUT, $OUTPUT) = @_;
    my($cmd, $rval);

TOP: while(<$INPUT>) {
	tr/\015//d;
	if  (/[>#]\s?exit$/) {
	    $clean_run = 1;
	    print STDERR "exiting\n" if ($debug);
	    last;
	}
	if (/^Error:/) {
	    print STDOUT ("$host ahlogin error: $_");
	    print STDERR ("$host ahlogin error: $_") if ($debug);
	    $clean_run = 0;
	    last;
	}
	while (/#\s*($cmds_regexp)\s*$/) {
	    $cmd = $1;
	    if (!defined($prompt)) {
		$prompt = ($_ =~ /^([^#]+#)/)[0];
		$prompt =~ s/([][}{)(\\])/\\$1/g;
		print STDERR ("PROMPT MATCH: $prompt\n") if ($debug);
	    }
	    print STDERR ("HIT COMMAND:$_\n") if ($debug);
	    if (! defined($commands{$cmd})) {
		print STDERR "$host: found unexpected command - \"$cmd\"\n";
		$clean_run = 0;
		last TOP;
	    }
	    if (! defined(&{$commands{$cmd}})) {
		printf(STDERR "$host: undefined function - \"%s\"\n",
		       $commands{$cmd});
		$clean_run = 0;
		last TOP;
	    }
	    $rval = &{$commands{$cmd}}($INPUT, $OUTPUT, $cmd);
	    delete($commands{$cmd});
	    if ($rval == -1) {
		$clean_run = 0;
		last TOP;
	    }
	    if (/[>#]\s?exit$/) {
		print STDERR ("$host: found exit\n") if ($debug);
		$clean_run = 1;
		last TOP;
	    }
	}
    }
}


# This routine parses "show version"
sub ShowVersion {
    my($INPUT, $OUTPUT, $cmd) = @_;
    print STDERR "    In ShowVersion: $_" if ($debug);

    while (<$INPUT>) {
	tr/\015//d;
	last if (/^$prompt/);
	next if (/^(Copyright|Aerohive)/);
	next if (/^Uptime:/);
	next if (/^\s+\^$/);

	ProcessHistory("COMMENTS","","","! $_");
    }
    ProcessHistory("COMMENTS","","","!\n");
    return 0;
}

# This routine parses "show running-config password"
sub WriteTerm {
    my($INPUT, $OUTPUT, $cmd) = @_;
    my $linecnt = 0;
    print STDERR "    In WriteTerm: $_" if ($debug);

    while (<$INPUT>) {
	tr/\015//d;
	last if (/^$prompt/);
	next if (/^(\s*|\s*$cmd\s*)$/);
	next if (/^\s+\^$/);

	# skip emtpy lines at the beginning
#	if (!$linecnt && /^\s*$/) {
#	    next;
#	}
	$linecnt++;

	# these appear to be reversables
	# enable password level 15 encrypted z9111212555bd4b0d3bec0b98f7ddd6346
#        if (/^(enable )?(password|passwd)( level \d+)? / && $filter_pwds >= 1) {
#            ProcessHistory("ENABLE","","","!$1$2$3 <removed>\n");
#            next;
#        }
	# username cisco password encrypted z9111212555bd4b0d3bec0b98f7ddd6346 privilege 15
#        if (/^username (\S+)(\s.*)? password encrypted (\S+)/) {
#            if ($filter_pwds >= 1){
#                ProcessHistory("USER","keysort","$1",
#                               "!username $1$2 password encrypted <removed>$'");
#            } else {
#                ProcessHistory("USER","keysort","$1","$_");
#            }
#            next;
#        }

	# filter passwords
	# XXX hiveos likes to add single spaces behind some config lines, so when we test for EOL
	# always add a \s? so we match with or without trailing space

	# hive <hivename> password <password> 
	if(/^(hive \S+ password )\S+\s?$/ && $filter_pwds >= 2) {
		ProcessHistory("","","","!$1<removed>\n");
		next;
	}

	# admin <(root-admin|read-write|read-only)> <username> password <password>
	if(/^(admin (root-admin|read-write|read-only) \S+ password )\S+\s?$/ && $filter_pwds >= 2) {
		ProcessHistory("","","","!$1<removed>\n");
		next;
	}

	# security-object <object> security protocol-suite wpa2-aes-psk hex-key <hexkey>
	if(/^(security-object \S+ security protocol-suite wpa2-aes-psk hex-key )\S+\s?$/ && $filter_pwds >= 1) {
		ProcessHistory("","","","!$1<removed>\n");
		next;
	}

	# capwap client dtls hm-defined-passphrase <passphrase> key-id <id>
	if(/^(capwap client dtls hm-defined-passphrase )\S+( key-id (\S+))\s?$/ && $filter_pwds >= 2) {
		ProcessHistory("","","","!$1<removed>$2\n");
		next;
	}

	# application reporting upload <url> time-window <numeric> admin <user> password <password> (<basic|digest>)
	# basic is base64 so reversable, digest should be md5 hashed
	if(/^(application reporting upload \S+ time-window \d+ admin \S+ password )\S+ (\S+)\s?$/ &&
		(($filter_pwds >= 1 && $2 eq "basic") || $filter_pwds >= 2)) {
		ProcessHistory("","","","!$1<removed> $2\n");
		next;
	}

	# order/prune snmp statements
	# we only prune lines of the form
	# snmp-server host <ip> traps version 2c <community>
#	if (/^(snmp-server host (\d+\.\d+\.\d+\.\d+) traps.* )(\S+)$/) {
#            if ($filter_commstr) {
#                ProcessHistory("SNMPTRAPHOST","ipsort","$2","! $1<removed>\n");
#            } else {
#                ProcessHistory("SNMPTRAPHOST","ipsort","$2","$_");
#            }
#            next;
#	}
	# snmp reader version v2c community <community> <ip>
	# hivemanager-ng will convert "ip objects" names to ip addresses in the final config
	if (/^(snmp reader version v2c community )\S+ (\d+\.\d+\.\d+\.\d+)$/) {
		if ($filter_commstr) {
			ProcessHistory("SNMPSERVERHOST","ipsort","$2","!$1<removed> $2\n");
		} else {
			ProcessHistory("SNMPSERVERHOST","ipsort","$2","$_");
		}
		next;
	}

	# encrypted tacacs-server host <ip> key <keyhash> priority 1
	# encrypted tacacs-server key <keyhash>
#	if (/^(encrypted (tacacs|radius)-server\s.*\s?key) (\S+)/
#	    && $filter_pwds >= 1) {
#	    ProcessHistory("","","","!$1 <removed>$'"); next;
#	}

	# catch anything that wasnt matched above.
	ProcessHistory("","","","$_");

	# end of config.
	# XXX no definitive end of config marker.
    }

    # hiveos lacks a definitive "end of config" marker.  If we ave seen at least
    # 5 linus of write term output, we can be reasonably sure that we have the config.
    if ($linecnt > 5) { 
        $found_end = 1;
    }

    return(0);
}

1;
